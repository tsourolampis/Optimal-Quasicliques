/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package DenseSubgraph;

import GraphUtilities.Graph;
import java.io.*;
import java.util.*;
import mascoptLib.algos.digraph.MinCut;
import mascoptLib.graphs.*;

public class ExactMaxFlowGoldberg {
    
    public Collection<Integer> S; 
    private Graph G;

    public String datasetname;
    public double optFGreedy;
    //public int donttouch[]; 
    
    public ExactMaxFlowGoldberg(Graph myG)
    {
        this.G = myG;
        S = new HashSet<Integer>();              
    }    
    
    public void  ExactMaxFlowOptimizeGoldberg() throws IOException
    {
        System.out.println(" Running ...");
        long startTime = System.currentTimeMillis();
        G.setAllActive();

        int n = G.V();
        int m = G.E();
        double l = 0;
        double u = G.E();
        S = new HashSet<Integer>();
        Collection<Integer> best = null;
        int s = 0;
        int t = n+1;
        int count = 1;
        
        //Arc[][] arcs = new Arc[n+2][n+2];
        //Vertex[] sVertex = new Vertex[1];
        //Vertex[] tVertex = new Vertex[1];
        //DiGraph digraph = buildInitialDiGraph(arcs,sVertex,tVertex);
        
        while(u-l >= ((double)1.0)/(n*(n-1)))
        {
            double g = (u+l)/2;
            
            System.out.println("Iteration "+count+" started (g="+g+")");
            
            //build graph
            VertexSet mc = getMinCutVertices(g);
            
            /*
            System.out.print("Updating weights for vertes-to-sink edges...");
            setWeightsToVertex2SinkEdges(arcs,g);
            System.out.println("DONE!");
            
            
            System.out.print("Running max-flow...");
            MinCut mcut = new MinCut(digraph,sVertex[0], sVertex[0]);
            mcut.run();
            System.out.println("DONE!");
            VertexSet mc = mcut.vertexSetCutMin();
            */
            
            /*
            for(Object v:mc)
            {
                System.out.println(((Vertex)v).getX());
            }
            */
            
            System.out.print("Checking cut...");
            Collection<Integer> A = new HashSet<Integer>();
            for(Object v:mc)
            {
                A.add((int)((Vertex)v).getX());
            }
            if(!A.contains(s))
            {
                Collection<Integer> Abar = new HashSet<Integer>();
                for(int x=1; x<=n; x++)
                {
                    Abar.add(x);
                }
                Abar.add(s);
                Abar.add(t);
                
                for(int x:A)
                {
                    Abar.remove(x);
                }
                A = Abar;
            }
            
            if(A.size() == 1 && A.iterator().next() == s)
            {
                u = g;
            }
            else
            {
                l = g;
                best = A;
            }
            
            System.out.println("DONE!\n");
            
            count++;
        }
        
        for(int x:best)
        {
            S.add(x);
        }
        S.remove(s);      

        optFGreedy = G.Score_FAST(S); 
       // System.out.println("The end, score"+optFGreedy);
        long endTime = System.currentTimeMillis();
        double seconds =  (double)(endTime - startTime)/1000;
         System.out.println("Running Algorithm took " +seconds + " seconds");
         System.out.println("Objective function value= "+optFGreedy);
        printOutput_FAST(0);
    }

    
    public  void printOutput_FAST(int cocktail) throws IOException 
    {
            Collection<Integer> S_HashSet = S;
            
            /* write the induced subgraph to a file 
        File ff = new File("GoldbergInducedGraph"+datasetname+"_"+Math.random());
        ff.createNewFile();
        BufferedWriter bww = new BufferedWriter(new FileWriter(ff));
        Iterator iterator = S_HashSet.iterator();
        int nind = S_HashSet.size();
        int mind = G.InducedEdges_FAST(S_HashSet);
        int[] myS = new int[S_HashSet.size()];
        int counter = 0; 
        while(iterator.hasNext()){
            myS[counter++] = (Integer)iterator.next();
        }
       
        bww.write("Source\tTarget\tType\n"); 
        for(int u=0; u < nind; u++)
            for(int v=u+1; v< nind; v++)
            {
                System.out.println("u "+u+" v "+v+" myS[u] "+myS[u]+" myS[v] "+myS[v]+" nind "+nind);
                if( G.hasEdge(myS[u], myS[v]))
                   bww.write(myS[u]+"\t"+myS[v]+"\tUndirected\n");         
            }
          bww.close();
        
        */
        
            System.out.println(" Computing induced edges ...");
            long startTime = System.currentTimeMillis();
            int induced = G.InducedEdges_FAST(S_HashSet);
            long endTime = System.currentTimeMillis();
            double seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Induced Edges took " +seconds + " seconds");

            System.out.println(" Computing induced triangles ...");
            startTime = System.currentTimeMillis();
            int triangles = G.InducedTriangles_FAST(S_HashSet);
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Induced triangles took " +seconds + " seconds");


            System.out.println(" Computing order of S ...");
            startTime = System.currentTimeMillis();
            int sizeofS = S_HashSet.size();
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Computing order of S took " +seconds + " seconds");

            double avgdegree = (double)induced/(double)sizeofS;
            double density = (double)induced/((double)(sizeofS*(sizeofS-1))/2);
            double tdensity = (double)triangles/((double)(sizeofS*(sizeofS-1)*(sizeofS-2))/6);

            System.out.println(" Computing Conductance of S ...");
            startTime = System.currentTimeMillis();
            double phi=G.Conductance_FAST(S_HashSet);
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Computing Conductance of S took " +seconds + " seconds");

            System.out.println(" Computing Ncut of S ...");
            startTime = System.currentTimeMillis();
            double ncut = G.NCut_FAST(S_HashSet);
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Computing Ncut of S took " +seconds + " seconds");


            System.out.println(" Computing Expansion of S ...");
            startTime = System.currentTimeMillis();
            double expansion =G.Expansion_FAST(S_HashSet);
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Computing Expansion of S took " +seconds + " seconds");


            System.out.println(" Computing edges across the cut (S,V-S) ...");
            startTime = System.currentTimeMillis();
            int edgesacross = G.EdgesAcrossCut_FAST(S_HashSet);
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Computing edges across took " +seconds + " seconds");


            System.out.println(" Computing cut ratio of S ...");
            startTime = System.currentTimeMillis();
            double cutratio = G.CutRatio_FAST(S_HashSet);
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Computing  cut ratio of S took " +seconds + " seconds");


            System.out.println(" Computing induced diameter ...");
            startTime = System.currentTimeMillis();
            int diam = G.InducedDiameter_FAST(S_HashSet);
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Induced Diameter took " +seconds + " seconds");

            System.out.println(" Computing heuristic induced diameter ...");
            startTime = System.currentTimeMillis();
            int hdiam = G.HeuristicInducedDiameter_FAST(S_HashSet);
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Induced Diameter took " +seconds + " seconds");


            String filename = "ExactMaxFlowGoldberg"+G.alpha+datasetname+"_"+Math.random();
            if( cocktail == 1)
                filename = "Cocktail"+filename;
            File f = new File(filename);
            f.createNewFile();
            BufferedWriter bw = new BufferedWriter(new FileWriter(f));
            bw.write("Optimal Value "+optFGreedy+"\n");


            bw.write("Induced edges "+induced+"\n");
            bw.write("Induced triangles "+triangles+"\n");
            bw.write("Order of S "+sizeofS+"\n");
            bw.write("Edge Density "+density+"\n");
            bw.write("Triangle Density "+tdensity+"\n") ;
            bw.write("Induced Diameter "+diam+"\n");
            bw.write("Induced Diameter with Aris Heuristic "+hdiam+"\n");
            bw.write("Edges across cut "+edgesacross+"\n");
            bw.write("Conductance of bipartition "+phi+"\n");
            bw.write("Cut ratio of bipartition "+cutratio+"\n");
            bw.write("Expansion "+expansion+"\n");
            bw.write("Normalized cut "+ncut+"\n");
            bw.write("Avg. degree "+avgdegree+"\n");
            bw.write("Optimal subset\n");
            for(int i:S_HashSet)
                bw.write(i+"\n");
            bw.flush();
            bw.close();
    }

    private VertexSet getMinCutVertices(double g) 
    {
        int n = G.V();
        int m = G.E();
        int s = 0;
        int t = n+1;
        
        System.out.println("Buiding network...");
        Map<Integer,Vertex> vertices = new HashMap<Integer,Vertex>();
        VertexSet vs = new VertexSet();
        for(int x=1; x<=n; x++)
        {
            Vertex v = new Vertex(x,-1);
            vs.add(v);
            vertices.put(x, v);
        }
        Vertex v = new Vertex(s,-1);
        vs.add(v);
        vertices.put(s, v);
        
        v = new Vertex(t,-1);
        vs.add(v);
        vertices.put(t, v);
        
        ArcSet es = new ArcSet(vs);
        int count = 1;
        int totM = m*2;
        for(int x=1; x<=n; x++)
        {
            for(int y:G.adjacentTo(x))
            {
                Arc a = new Arc(vertices.get(x), vertices.get(y));
                a.setDouValue("capacity", 1);
                es.add(a);
                if (count%(totM*0.05)==0)
                {
                    System.out.println("Added "+count+" edges of "+totM);
                }
                count++;
            }
        }
        
        System.out.println("Adding edges to source s...");
        for(int x=1; x<=n; x++)
        {
            Arc a = new Arc(vertices.get(s), vertices.get(x));
            a.setDouValue("capacity", m);
            es.add(a);
        }
        
        System.out.println("Adding edges to sink t...");
        for(int x=1; x<=n; x++)
        {
            Arc a = new Arc(vertices.get(x), vertices.get(t));
            double w = m+2*g-G.degreeAssumingAllActive(x);
            a.setDouValue("capacity", w);
            es.add(a);
        }
        
        DiGraph dg = new DiGraph(vs, es);
        System.out.println("DONE!");
        
        System.out.print("Running max-flow...");
        MinCut mc = new MinCut(dg,vertices.get(s), vertices.get(t));
        mc.run();
        System.out.println("DONE!");
        return mc.vertexSetCutMin();
    }
    
    /*
    private VertexSet getMinCutVertices(double g) 
    {
        int n = 6;
        int m = 9;
        int s = 0;
        int t = n+1;
        
        Map<Integer,Vertex> vertices = new HashMap<Integer,Vertex>();
        VertexSet vs = new VertexSet();
        for(int x=1; x<=n; x++)
        {
            Vertex v = new Vertex(x,-1);
            vs.add(v);
            vertices.put(x, v);
        }
        Vertex v = new Vertex(s,-1);
        vs.add(v);
        vertices.put(s, v);
        
        v = new Vertex(t,-1);
        vs.add(v);
        vertices.put(t, v);
        
        ArcSet es = new ArcSet(vs);
        addEdge(es,vertices,s,1,5);
        addEdge(es,vertices,s,2,5);
        addEdge(es,vertices,1,3,1);
        addEdge(es,vertices,2,3,1);
        addEdge(es,vertices,3,4,3);
        addEdge(es,vertices,4,5,5);
        addEdge(es,vertices,4,6,5);
        addEdge(es,vertices,5,t,5);
        addEdge(es,vertices,6,t,5);

        DiGraph dg = new DiGraph(vs, es);
        MinCut mc = new MinCut(dg,vertices.get(s), vertices.get(t));
        mc.run();
        return mc.vertexSetCutMin();
    }

    private void addEdge(ArcSet es, Map<Integer, Vertex> vertices, int x, int y, double w) 
    {
        Arc a = new Arc(vertices.get(x),vertices.get(y));
        a.setDouValue("capacity", w);
        es.add(a);
    }
    */

    private DiGraph buildInitialDiGraph(Arc[][] arcs, Vertex[] sVertex, Vertex[] tVertex) 
    {
        int n = G.V();
        int m = G.E();
        int s = 0;
        int t = n+1;
        
        System.out.println("Buiding initial max-flow network...");
        Map<Integer,Vertex> vertices = new HashMap<Integer,Vertex>();
        VertexSet vs = new VertexSet();
        for(int x=1; x<=n; x++)
        {
            Vertex v = new Vertex(x,-1);
            vs.add(v);
            vertices.put(x, v);
        }
        Vertex v = new Vertex(s,-1);
        vs.add(v);
        vertices.put(s, v);
        sVertex[0] = v;
        
        v = new Vertex(t,-1);
        vs.add(v);
        vertices.put(t, v);
        tVertex[0] = v;
        
        ArcSet es = new ArcSet(vs);
        int count = 1;
        int totM = m*2;
        for(int x=1; x<=n; x++)
        {
            for(int y:G.adjacentTo(x))
            {
                Arc a = new Arc(vertices.get(x), vertices.get(y));
                a.setDouValue("capacity", 1);
                es.add(a);
                arcs[x][y] = a;
                if (count%(totM*5/100)==0)
                {
                    System.out.println("Added "+count+" edges of "+totM);
                }
                count++;
            }
        }
        
        System.out.println("Adding edges to source s...");
        for(int x=1; x<=n; x++)
        {
            Arc a = new Arc(vertices.get(s), vertices.get(x));
            a.setDouValue("capacity", m);
            es.add(a);
            arcs[s][x] = a;
        }
        
        System.out.println("Adding edges to sink t...");
        for(int x=1; x<=n; x++)
        {
            Arc a = new Arc(vertices.get(x), vertices.get(t));
            double w = 1;//tmp 'fake' weight: it will be updated at each iteration based on the value of g 
            a.setDouValue("capacity", w);
            es.add(a);
            arcs[x][t] = a;
        }
        
        DiGraph dg = new DiGraph(vs, es);
        System.out.println("DONE!");
        
        return dg;
    }

    private void setWeightsToVertex2SinkEdges(Arc[][] arcs, double g) 
    {
        int n = G.V();
        int m = G.E();
        int t = n+1;
        
        for(int x=1; x<=n; x++)
        {
            double w = m+2*g-G.degreeAssumingAllActive(x); 
            arcs[x][t].setDouValue("capacity", w);
        }
    }
}
