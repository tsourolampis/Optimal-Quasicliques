/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package DenseSubgraph;

import GraphUtilities.Graph;
import java.io.*;
import java.util.*;
/**
 *
 * @author Charalampos E. Tsourakakis
 */
public class GreedyCharikar {
    
    public Collection<Integer> S; 
    private Graph G;

    public String datasetname;
    public double optFGreedy;
    //public int donttouch[]; 
    
    public GreedyCharikar(Graph myG)
    {
        this.G = myG;
        S = new HashSet<Integer>();              
    }
    
    public void GreedyOptimizeCharikar() throws IOException
    {
        GreedyOptimizeCharikar(-1);
    }
    
    public void GreedyOptimizeCharikar(int printing)  throws IOException
    {
        G.setAllActive();
        runGreedyOptimizeCharikar(printing);
        printOutput_FAST(0,printing);
    }
    
    public double[][] GreedyOptimizeCharikar_TopK(int k) throws IOException
    {
        System.out.println(" Running ...");
        long startTime = System.currentTimeMillis();
        
        int[][] output = new int[k][G.V()+1];
        S = new HashSet<Integer>();
        
        G.setAllActive();
        boolean stop = false;
        int i=0;
        double[][] out = new double[k][7];
        String[] outString = new String[k];
        for (; i<k && !stop; i++)
        {
        //initialize partition
            S = new HashSet<Integer>();

            runGreedyOptimizeCharikar(i+1);
            
            String[] s = new String[1];
            double[] v = outputTopK(i+1, s);
            for(int j=0; j<v.length; j++)
            {
                out[i][j] += v[j];
            }
            outString[i] = s[0];
            
            for(int j:S)
            {
                G.exist[j] = false;
                output[i][j] = 1;
            }
            
            int count = 0;
            for (int j=1; j<=G.V(); j++)
            {
                if (G.exist[j])
                {
                    count++;
                }
            }
            if(count == 0)
            {
                stop = true;
            }
        }
        
        for (int h=i; h<output.length; h++)
        {
            output[h] = null;
        }
       // System.out.println("The end, score"+optFGreedy);
        long endTime = System.currentTimeMillis();
        double seconds =  (double)(endTime - startTime)/1000;
         System.out.println("Running Algorithm took " +seconds + " seconds");
         System.out.println("Objective function value= "+optFGreedy);
         
         //checkOverlap(output);
         
         return out;
    }
    
    public double[] outputTopK(int k, String[] output)
    {
        String c = ",";
        String s = datasetname+c+k+c;
        
        Collection<Integer> S_HashSet = S;

        int size = S_HashSet.size();
        int eS = G.InducedEdges_FAST(S_HashSet);
        int D = G.InducedDiameter_FAST(S_HashSet);
        //int D = G.HeuristicInducedDiameter_FAST(S_HashSet);
        double fd = (size==0)?0.0:((double)(2*eS)/(double)size);
        double falpha = optFGreedy;
        double fe = (size<=1)?0.0:((double)eS/((double)(size*(size-1))/2));
        int triangles = G.InducedTriangles_FAST(S_HashSet);
        double ft = (size<=2)?0.0:((double)triangles/((double)(size*(size-1)*(size-2))/6));
        
        s += size+c;
        s += eS+c;
        s += D+c;
        s += fd+c;
        s += falpha+c;
        s += fe+c;
        s += ft;
        
        output[0] = s;
        return new double[]{size,eS,D,fd,falpha,fe,ft};  
    }
    
    public void runGreedyOptimizeCharikar(int printing) throws IOException
    {
        System.out.println(" Running ...");
        long startTime0 = System.currentTimeMillis();
        long startTime = System.currentTimeMillis();
        //G.setAllActive();

        Map<Integer,Collection<Integer>> graph = loadGraph();
        long endTime0 = System.currentTimeMillis();
        System.out.println("Load graph took "+ (endTime0 - startTime0) +" milli secs");
        
        /*
        System.out.println("n="+graph.size());
        int s = 0;
        for(int x:graph.keySet())
        {
            s += graph.get(x).size();
        }
        System.out.println("m="+(s/2));
        */
        
        System.out.print("Computing densest subgraph...");
        
        
        startTime0 = System.currentTimeMillis();
        double avgDegree = 0.0;
        for(int x:graph.keySet())
        {
            avgDegree += graph.get(x).size();
        }
        avgDegree /= graph.size();
        endTime0 = System.currentTimeMillis();
        System.out.println("Avg degree took "+ (endTime0 - startTime0) +" milli secs");
        
        startTime0 = System.currentTimeMillis();
        Collection<Integer>[] degrees = new Collection[graph.size()+1];
        for (int i=0; i<degrees.length; i++)
        {
            degrees[i] = new HashSet<Integer>();
        }
        for(int x:graph.keySet())
        {
            degrees[graph.get(x).size()].add(x);
        }
        int i=0;
        while(i<degrees.length && degrees[i].isEmpty())
        {
            i++;
        }
        endTime0 = System.currentTimeMillis();
        System.out.println("Placing vertices to buckets "+ (endTime0 - startTime0) +" milli secs");
        
        
      
          S = new HashSet<Integer>();
        for(int z:graph.keySet())
        {
            S.add(z);
        }
        double max = avgDegree;
        Collection<Integer> acc = new HashSet<Integer>();  
        startTime0 = System.currentTimeMillis();
        while(i<degrees.length)
        {
            //System.out.print(".");
            int x = degrees[i].iterator().next();
            int den = (graph.size()==1)?1:graph.size()-1;
            avgDegree = (avgDegree*graph.size()-(i*2))/den;
            
            for(int y:graph.get(x))
            {
                int d = graph.get(y).size();   
                degrees[d].remove(y);
                degrees[d-1].add(y);
                graph.get(y).remove(x);
            }
            graph.remove(x);
            degrees[i].remove(x);
            
            
            acc.add(x);
            if (avgDegree > max)
            {
                max = avgDegree;
                
                 for (int y:acc)
                {
                    S.remove(y);
                }
                acc = new HashSet<Integer>();
            }
            
            if(i>0 && !degrees[i-1].isEmpty())
            {
                i=i-1;
            }
            else
            {
                while(i<degrees.length && degrees[i].isEmpty())
                {
                    i++;
                }
            }
        }
        endTime0 = System.currentTimeMillis();
        System.out.println("Iterating "+ (endTime0 - startTime0) +" milli secs");
        optFGreedy =  G.Score_FAST(S); 
       // System.out.println("The end, score"+optFGreedy);
         long endTime = System.currentTimeMillis();
         double seconds =  (double)(endTime - startTime)/1000;
         System.out.println("Running Charikar Algorithm took " +seconds + " seconds");
         System.out.println("Objective function value= "+optFGreedy);
    }
    
    
    
    
    private Map<Integer, Collection<Integer>> loadGraph() 
    {
        Map<Integer,Collection<Integer>> graph = new HashMap<Integer, Collection<Integer>>();
        
        for (int x=1; x<=G.V(); x++)
        {
            if (G.exist[x])
            {
                Collection<Integer> neighbors = new HashSet<Integer>();
                for(int y:G.adjacentTo(x))
                {
                    if(G.exist[y])
                    {
                        neighbors.add(y);
                    }
                }
                graph.put(x, neighbors);
            }
        }
        
        return graph;
    }

    
    public  void printOutput_FAST(int cocktail,int printing) throws IOException 
    {
            Collection<Integer> S_HashSet = S;
        
            System.out.println(" Computing induced edges ...");
            long startTime = System.currentTimeMillis();
            int induced = G.InducedEdges_FAST(S_HashSet);
            long endTime = System.currentTimeMillis();
            double seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Induced Edges took " +seconds + " seconds");

            System.out.println(" Computing induced triangles ...");
            startTime = System.currentTimeMillis();
            int triangles = G.InducedTriangles_FAST(S_HashSet);
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Induced triangles took " +seconds + " seconds");


            System.out.println(" Computing order of S ...");
            startTime = System.currentTimeMillis();
            int sizeofS = S_HashSet.size();
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Computing order of S took " +seconds + " seconds");

            double avgdegree = (double)induced/(double)sizeofS;
            double density = (double)induced/((double)(sizeofS*(sizeofS-1))/2);
            double tdensity = (double)triangles/((double)(sizeofS*(sizeofS-1)*(sizeofS-2))/6);

            System.out.println(" Computing Conductance of S ...");
            startTime = System.currentTimeMillis();
            double phi=G.Conductance_FAST(S_HashSet);
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Computing Conductance of S took " +seconds + " seconds");

            System.out.println(" Computing Ncut of S ...");
            startTime = System.currentTimeMillis();
            double ncut = G.NCut_FAST(S_HashSet);
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Computing Ncut of S took " +seconds + " seconds");


            System.out.println(" Computing Expansion of S ...");
            startTime = System.currentTimeMillis();
            double expansion =G.Expansion_FAST(S_HashSet);
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Computing Expansion of S took " +seconds + " seconds");


            System.out.println(" Computing edges across the cut (S,V-S) ...");
            startTime = System.currentTimeMillis();
            int edgesacross = G.EdgesAcrossCut_FAST(S_HashSet);
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Computing edges across took " +seconds + " seconds");


            System.out.println(" Computing cut ratio of S ...");
            startTime = System.currentTimeMillis();
            double cutratio = G.CutRatio_FAST(S_HashSet);
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Computing  cut ratio of S took " +seconds + " seconds");


            System.out.println(" Computing induced diameter ...");
            startTime = System.currentTimeMillis();
            int diam = G.InducedDiameter_FAST(S_HashSet);
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Induced Diameter took " +seconds + " seconds");

            System.out.println(" Computing heuristic induced diameter ...");
            startTime = System.currentTimeMillis();
            int hdiam = G.HeuristicInducedDiameter_FAST(S_HashSet);
            endTime = System.currentTimeMillis();
            seconds =  (double)(endTime - startTime)/1000;
            System.out.println("Induced Diameter took " +seconds + " seconds");

            
            String suffix = (printing==-1)?"":("Top"+printing+"_");
            String filename = "GreedyCharikar"+G.alpha+datasetname+"_"+suffix+Math.random();
            if( cocktail == 1)
                filename = "Cocktail"+filename;
            File f = new File(filename);
            f.createNewFile();
            BufferedWriter bw = new BufferedWriter(new FileWriter(f));
            bw.write("Optimal Value "+optFGreedy+"\n");


            bw.write("Induced edges "+induced+"\n");
            bw.write("Induced triangles "+triangles+"\n");
            bw.write("Order of S "+sizeofS+"\n");
            bw.write("Edge Density "+density+"\n");
            bw.write("Triangle Density "+tdensity+"\n") ;
            bw.write("Induced Diameter "+diam+"\n");
            bw.write("Induced Diameter with Aris Heuristic "+hdiam+"\n");
            bw.write("Edges across cut "+edgesacross+"\n");
            bw.write("Conductance of bipartition "+phi+"\n");
            bw.write("Cut ratio of bipartition "+cutratio+"\n");
            bw.write("Expansion "+expansion+"\n");
            bw.write("Normalized cut "+ncut+"\n");
            bw.write("Avg. degree "+avgdegree+"\n");
            bw.write("Optimal subset\n");
            for(int i:S_HashSet)
                bw.write(i+"\n");
            bw.flush();
            bw.close();
    }

    private void checkOverlap(int[][] output) 
    {
        for (int j=0; j<output[0].length; j++)
        {
            int x = 0;
            for (int i=0; i<output.length; i++)
            {
                x += output[i][j];
            }
            
            if (x > 1)
            {
                throw new RuntimeException("ERROR");
            }
        }
        
    }


    
    
    
    
    
     
}
